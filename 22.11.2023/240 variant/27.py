import math
f=open('source/27_B-3.txt')
k=10000000 # длина массива
n, m=f.readline().split()
a=[0]*k
sm=0
for i in range(int(n)):
    x, y = f.readline().split()
    x=int(x)
    y=int(y)
    z = math.ceil(y/30)
    a[x] = z
    sm +=(x-1)*z

# Вспомогательные суммы
s1=[]
s2=[]
s1.append(0)
s2.append(0)
s1.append(0)
s2.append(0)

for i in range(1, k):
    s1[1] = s1[1] + a[i]

for i in range(2, k):
    s1.append(s1[i-1] - a[i-1])
    s2.append(s2[i-1] + a[i-1])

# Ищем минимальное значение
mn=sm

for i in range(2,  k):
    sm = sm - s1[i] + s2[i]
    mn=min(mn, sm)

print(mn)

# Переменная k - это количество приёмных пунктов (Т.е. длина массива a). Превая ячейка соответсвует приёмному пункту под номером 1, вторая ячейка под номером 2 и т.д. Само значение для k мы смотрим в конце файла. Например, для файла A значение напишем 999. Всего 998 приёмных пунктов, но т.к. индексы в массиве начинаются с 0, то мы должны завести 999 ячеек. Т.е. нулевая ячейка не будет никак задействована. Для файла B устанавливаем k в 9999995.
# В сами ячейки массива мы поместим для каждого приёмного пункта количество контейнеров. Их легко вычислить. Если количество пробирок не нулевое, то мы должны это количество разделить на 36 и округлить в большую сторону. Количество контейниров в нашей программе для каждого приёмного пункта - это переменная z.
# Пусть лаборатория расположена в первом пункте. Тогда вычислим для неё стоимость доставки:
# sm1 = a[2]*1 + a[3]*2 + a[4]*3 + ... + a[m]*(m-1)
# Здесь m - это последний индекс массива a (m = k-1). Пусть лаборатория будет во втором пункте, тогда:
# sm2= a[3]*1 + a[4]*2 + ... + a[n]*(m-2) + a[1] = sm1 - (a[2] + a[3] + a[4] + ... + a[m]) + a[1]
# Отсюда мы понимаем, что достаточно вычислить стоимость доставки sm1 по формуле, которую нам дали в задаче, только один раз для первого пункта. Для второго пункта вычисляем: sm2 = sm1 - (a[2] + a[3] + a[4] + ... + a[m]) + a[1]. Для третьего sm3 = sm2 - (a[3] + a[4] + ... + a[m]) + a[2] + a[1] и т.д.
# Значит, для каждого приёмного пункта i мы должны иметь уже готовую вспомагательную сумму s1[i] = a[i] + a[i+1] + ...+ a[m], а так же сумму s2, т.е. сумма элементов, которые идут левее i (само a[i] уже не берётся): s2[i] = s[1] + s[2] + ... + s[i-1].
# Сумму s1[i] мы должны отнимать, а s2[i] прибавлять. По мерее продвижения по нашим приёмным пунктам, s1[i] будет уменьшаться, а s2[i] увеличиваться.
# Но вспомогательные суммы s1[i] и s2[i] нужно тоже вычислисть, как можно эффективней. Достаточно вычислить для s1[1] и s2[1] (для первого приёмного пункта), а дальше можно воспользоваться закономерностью: s1[2] = s1[1]-a[1], s1[3] = s1[2]-a[2]...и т.д. Так же s2[2] = s[1]+a[1], s[3] = s[2]+a[2] и т.д.
# s1[0] и s2[0] не нужны, они соответсвуют a[0], а она не используется при решении задачи. Значение s1[1] вычисляем "честно" с помощью цикла. Значение s2[1] = 0 (левее нет ячеек).
# В самом первом цикле вычисляется значение для переменной sm - это стоимость перевозки, если лаборатория стоит в первом пункте. В последнем цикле программы вычисляем стоимоть для всех остальных приёмных пунктов, используя вышеописанные алгоритмы. И находим минимальное значение среди всех значений для переменной sm.
